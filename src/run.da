from replica import Replica
from client import Client
import leaderelection
import random
from nacl.signing import SigningKey
import sys
from collections import namedtuple
from enum import Enum

class Run(process):
	def setup(config):
		self.num_replicas = config.num_replicas
		self.num_faulty = config.num_faulty
		self.workloads = config.workloads
		self.transmission_delay_bound = config.transmission_delay_bound
		if config.seed == None:
			self.seed = random.randomint(0, sys.maxsize)
		else:
			self.seed = config.seed
		output('using random seed: %d' % self.seed)

	def run():
		num_clients = sum([wkld.num_clients for wkld in self.workloads])
		output('Starting run with %d replicas, %d faulty replicas, and %d clients' % (num_replicas, num_faulty, num_clients))
		replicas = new(Replica, num=num_replicas)
		clients = new(Client, num=num_clients)
		random.seed(seed)
		private_keys = {'replica' + str(i): SigningKey(random.getrandbits(256).to_bytes(32, 'big')) for i in range(num_replicas)}
		private_keys.update({'client' + str(i): SigningKey(random.getrandbits(256).to_bytes(32, 'big')) for i in range(num_clients)})
		public_keys = {'replica' + str(i): private_keys['replica' + str(i)].verify_key for i in range(num_replicas)}
		public_keys.update({'client' + str(i): private_keys['client' + str(i)].verify_key for i in range(num_clients)})
		# we use str(replica) to get unique replica id's
		# but these are not reproducible
		# so override __str__ to return unique index
		# jk distalgo doesn't allow that, use to_str()
		for i, replica in enumerate(replicas):
			setup(replica, (replicas, clients, transmission_delay_bound, public_keys, private_keys['replica' + str(i)], i, random.random()))
		for i, (client, workload) in enumerate(zip(clients, workloads)):
			setup(client, (replicas, self, workload, public_keys, private_keys['client' + str(i)], i, random.random()))
		start(replicas | clients)
		await(each(c in clients, has=received(('done',), from_=c)))
		output('All clients finished sending requests')
		send(('done',), to=replicas)

FailureConfig = namedtuple('FailureConfig', ['failures', 'seed'], defaults=(None))
Failure = namedtuple('Failure', ['src', 'dest', 'msg_type', 'round', 'prob', 'fail_type', 'val', 'attr'], defaults=(None, None))

class MsgType(Enum):
	Proposal = 1
	QC = 2
	TimeOut = 3
	Vote = 4
	Wildcard = 5 # matches all message types

class FailType(Enum):
	MsgLoss = 1
	Delay = 2
	SetAttr = 3

Workload = namedtuple('Workload', ['type', 'count', 'num_clients', 'delays'], defaults=([],))
Config = namedtuple('Config', ['num_replicas', 'num_faulty', 'workloads', 'transmission_delay_bound', 'seed'], defaults=(None,))

class WorkloadType(Enum):
	retransmit = 1
	flood = 2
	timed = 3

def main():
	configs = [
		Config(
			num_replicas = 5,
			num_faulty = 0,
			workloads = [
				Workload(
					type = WorkloadType.retransmit,
					count = 5,
					num_clients = 1
				)
			],
			transmission_delay_bound = 1,
			seed = 0
		)
	]
	for config in configs:
		r = new(Run, (config,))
		start(r)
