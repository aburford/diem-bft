from replica import Replica
from replicafi import ReplicaFI
from client import Client
import leaderelection
import random
from uuid import uuid4
from nacl.signing import SigningKey
import sys
from config import *
from logger import createLogger
import os
import importlib
from config import *


class TestExec(process):
    def setup(test_config):
        # Stoller recommends doing this for macOS where UDP max datagram size is too small so this forces TCP
        self.num_replicas = len(test_config.replicas)
        self.num_faulty = len(test_config.twins)
        self.seed = test_config.seed
        self.transmission_delay_bound = test_config.transmission_delay_bound
        self.nrounds = len(test_config.rounds)
        self.leaders = {i: r.leader for i, r in enumerate(test_config.rounds)}
        self.gst = test_config.gst
        formatter ='%(asctime)s:%(message)s'
        self.logger = createLogger(__name__, f"log/{test_case}_run.log",formatter)
        self.replicas = list(new(ReplicaTestExec, num=(num_replicas + num_faulty)))
        random.seed(seed)
        private_keys = {
            r: SigningKey(random.getrandbits(256).to_bytes(32, 'big'))
            for r in test_config.replicas
        }
        public_keys = {
            r: private_keys[r].verify_key
            for r in test_config.replicas
        }
        self.process_to_id = {}
        self.id_to_process = {}
        for r, ident in zip(replicas, (test_config.replicas + test_config.twins)):
            process_to_id[r] = ident
            ident = ident[0]
            id_to_process.setdefault(ident, []).append(ident)
        self.partitions = {}
        for rnd_num, rnd in enumerate(test_config.rounds):
            parts = {}
            for i, p in enumerate(rnd.partitions):
                for r in p:
                    # convert d' to d twin process
                    processes = id_to_process[r[0]]
                    proc = processes[len(r)-1]
                    parts[proc] = i
            self.partitions[rnd_num] = parts
        txns = []
        alpabet = [chr(x) for x in range(ord('a'), ord('z') + 1)]
        for _ in range(len(test_config.round * mempool.BLOCK_SIZE * 2)):
            txn = [random.choice(alphabet) for _ in range(6)]
            txns.append((uuid4().hex, ''.join(txn)))
        for replica in replicas:
            logger.debug(f'[setting up replicafi {replica}]')
            ident = self.process_to_id[replica]
            setup(
                replica, (
                    self,
                    test_config.replicas,
                    transmission_delay_bound,
                    public_keys,
                    private_keys[ident],
                    ident,
                    random.random(),
                    num_faulty,
                    txns.copy(),
                    leaders,
                    test_config.name
                )
            )
            random.shuffle(txns)
        self.t= test_config.timeout

    def run():
        logger.debug(f'Starting run with {num_replicas} replicas,{num_faulty} faulty replicas')
        start(replicas)
        if await(each(r in replicas, has=sent(('done',), to=_r))):
            logger.debug('[all replicas reached desired round]')
            # check offline liveness/safety properties

        elif timeout(t):
            logger.debug('[entire test case timeout]')

    def can_send(src, dst, r):
        part = partitions[r]
        if part[src] != part[dst]:
            return False
        for e in test_config.rounds[r].exceptions:
            if process_to_id[src] == e.src and process_to_id[dst] == e.dst:
                return False
        return True

    # DPI
    def get_round(msg):
        msg_type = msg[0]
        if msg_type == 'proposal':
            return msg[1].block.round
        elif msg_type == 'vote':
            return msg[1].vote_info.round
        elif msg_type == 'timeout':
            return msg[1].tmo_info.round
        # TODO don't think we should be blocking these?
        #elif msg_type == 'sync_request':
        #elif msg_type == 'sync_response':

    def receive(msg=M, from_=sender):
        dst, msg = M
        rnd = get_round(msg)
        if rnd == nrounds:
            done_msg = (('done',), 'executor')
            if not sent(done_msg, to=_sender):
                send(done_msg, sender)
                logger.debug(f'[{process_to_id[sender]} reached final round]')
            return
        src = process_to_id[sender][0]
        receivers = id_to_process[dst]
        for receiver in receivers:
            if can_send(sender, receiver, rnd):
                send((msg, src), proc)

def main():
    config(channel = 'reliable')
    test_cases = []
    # TODO parse list of TestConfig from file generated by test generator
    #if len(sys.argv) > 1:
    #    test_case_names = sys.argv[1:]
    #else:
    #    test_case_names = map(lambda s: s[:-3], filter(lambda s: '.da' in s, os.listdir('configs')))
    #for test_case_name in test_case_names:
    #    test_module = importlib.import_module("configs." + test_case_name)
    #    test_cases.append((
    #        test_case_name,
    #        test_module.config,
    #        test_module.failure_config
    #    ))

    if not(os.path.isdir("log")):
        os.mkdir("log")

    # manually create a test case
    rounds = [Round('a', [["a", "b", "d"], ["c", "d'"]], [])]
    test_cases.append(TestConfig(['a','b','c','d'], ["d'"], rounds, 0.2, 0, 'test', 30))

    for test_config in test_cases:
        r = new(TestExec, (test_config))
        start(r)
