from replica import Replica
import mempool
from replicatestexec import ReplicaTestExec
from testconfig import *
from client import Client
import leaderelection
import random
from uuid import uuid4
from nacl.signing import SigningKey
import sys
from config import *
from logger import createLogger
import os
import importlib
from config import *
from datetime import datetime


class TestExec(process):
    def setup(test_config):
        # Stoller recommends doing this for macOS where UDP max datagram size is too small so this forces TCP
        self.num_replicas = len(test_config.replicas)
        self.num_faulty = len(test_config.twins)
        self.test_case = test_config.name
        self.f = num_faulty
        self.twins = [ident[0] for ident in test_config.twins]
        self.seed = test_config.seed
        self.transmission_delay_bound = test_config.transmission_delay_bound
        self.nrounds = len(test_config.rounds)
        self.leaders = {i: r.leader for i, r in enumerate(test_config.rounds)}
        # repeat leader of last round because vote messages
        # in the last round need to be send to the leader
        # of the next round
        # TODO remember that this means a block could be committed by
        # one replica in round nrounds which might look like incorrect
        # behavior but i guess is how we'll do it.
        leaders[nrounds] = leaders[nrounds - 1]
        self.gst = test_config.gst
        formatter ='%(asctime)s:%(message)s'
        self.logger = createLogger(__name__, f"log/{test_case}_run.log",formatter)
        self.replicas = list(new(ReplicaTestExec, num=(num_replicas + num_faulty)))
        # used to verify property 4
        self.first_to_enter = dict()
        random.seed(seed)
        private_keys = {
            r: SigningKey(random.getrandbits(256).to_bytes(32, 'big'))
            for r in test_config.replicas
        }
        public_keys = {
            r: private_keys[r].verify_key
            for r in test_config.replicas
        }
        self.process_to_id = {}
        self.id_to_process = {}
        for r, ident in zip(replicas, (test_config.replicas + test_config.twins)):
            process_to_id[r] = ident
            ident = ident[0]
            id_to_process.setdefault(ident, []).append(r)
        self.partitions = {}
        for rnd_num, rnd in enumerate(test_config.rounds):
            parts = {}
            for i, p in enumerate(rnd.partition):
                for r in p:
                    # convert d' to d twin process
                    processes = id_to_process[r[0]]
                    proc = processes[len(r)-1]
                    parts[proc] = i
            self.partitions[rnd_num] = parts
        for replica in replicas:
            logger.debug(f'[setting up replicatestexec {replica}]')
            ident = self.process_to_id[replica][0]
            setup(
                replica, (
                    self,
                    test_config.replicas,
                    transmission_delay_bound,
                    public_keys,
                    private_keys[ident],
                    ident,
                    seed,
                    num_faulty,
                    leaders,
                    len(test_config.rounds),
                    test_config.name
                )
            )
        self.t = test_config.timeout
    
    # msg = (src/dst, (msg_type, content))

    # return block ids
    def blocks():
        return setof(msg[1][1].block.id, received(msg), msg[1][0] == 'proposal')

    # return (block_id, round, parent_id)
    def blocklinks():
        return setof((msg.block.id, msg.block.round, msg.block.qc.vote_info.id), received(msg), msg[1][0] == 'proposal')

    # return replica ids of all votes for specific block in a round
    # twins have same id
    def voters(block, rnd):
        return setof(msg[0][0], received(msg), msg[1][0] == 'vote' and msg[1][1].vote_info.id == block and msg[1][1].vote_info.round == rnd)

    def cert_blocks(rnd):
        return setof(block, block in blocks(), lenof(v, v in voters(block, rnd)) >= 2*f + 1)

    def weak_cert_blocks(rnd):
        return setof(block, block in blocks(), lenof(v, v in voters(block, rnd), v not in twins) >= f + 1)

    def global_commit_voters(block, rnd):
        return setof(msg[0][0], received(msg), msg[1][0] == 'vote' and msg[1][1].vote_info.parent_id == block and msg[1][1].vote_info.round == rnd)

    def is_global_commit(block, rnd):
        return lenof(v, v in global_commit_voters(block, rnd + 1), v not in twins) >= f + 1
    
    def get_global_commits():
        return setof((link[0], link[2]), link in blocklinks(), is_global_commit(link[0], link[1]))

    def safe_round(rnd):
        each(cert_block in cert_blocks(rnd), has=not some(block in weak_cert_blocks(rnd), has=block != cert_block))

    def run():
        logger.debug(f'Starting run with {num_replicas} replicas,{num_faulty} faulty replicas')
        start(replicas)
        # wait until every replica has sent a message in the last round
        print('test exec waiting for rounds to complete')
        if await(each(r in replicas, has=some(received(m, from_=_r), has=get_round(m[1]) == nrounds - 1))):
            print('all rounds completed')
            logger.debug('[all replicas reached desired round]')
            done_msg = (('done',), 'executor')
            super().send(done_msg, replicas)
            # property 1
            if not each(rnd in range(nrounds), has=safe_round(rnd)):
                logger.info('Property 1 violated')
            # property 2
            global_commits = get_global_commits()
            graph = {}
            for block, parent in graph:
                graph[parent] = block
            chain = []
            seen = set()
            violated = False
            block = None
            while block in graph:
                block = graph[block]
                if block in seen:
                    violated = True
                    break
                seen.add(block)
                chain.append(block)
            if violated or len(chain) != len(global_commits):
                logger.info('Property 2 violated')
            # property 3
            # technically the wording of property 3 means this hold true for all rounds after gst, not just the one immediately after
            honest = [procs[0] for ident, procs in id_to_process.items() if len(procs) == 1]
            if not each(r in honest, has=some(received(('committed', (_, rnd, _)), from_=_r), has= rnd > gst)):
                logger.info('Property 3 could be violated')
            # property 4
            violated = False
            for rnd in range(gst, nrounds):
                honest_leaders = True
                for i in range(3):
                    if leaders[rnd + i] in twins:
                        honest_leaders = False
                        break
                if honest_leaders:
                    time = first_to_enter[rnd]
                    for ident in test_config.replicas:
                        if ident in twins:
                            continue
                        # TODO get time stamp from log
                        proc = id_to_process[ident][0]
                        blocks = setof(msg.block.id, received(msg, from_=_honest), msg[1][0] == 'proposal' and msg[1][1].block.round == rnd)
                        if len(blocks) != 1:
                            logger.info('honest validator sent equivocating proposals (should never happen)')
                            violated = True
                            break
                        block_id = blocks[0]
                        log_time = setof(time, received(('committed', (_block_id, _rnd, time)), from_=_proc))[0]
                        if (log_time - time).total_seconds() > 7 * transmission_delay_bound:
                            violated = True
                            break
                if violated:
                    break
            if violated:
                logger.info('Property 4 violated')
        elif timeout(t):
            logger.debug('[entire test case timed out]')

    def can_send(src, dst, r):
        part = partitions[r]
        if part[src] != part[dst]:
            return False
        for e in test_config.rounds[r].exceptions:
            if process_to_id[src] == e.src and process_to_id[dst] == e.dst:
                return False
        return True

    # DPI
    def get_round(msg):
        msg_type = msg[0]
        if msg_type == 'proposal':
            return msg[1].block.round
        elif msg_type == 'vote':
            return msg[1].vote_info.round
        elif msg_type == 'timeout':
            return msg[1].tmo_info.round
        # TODO don't think we should be blocking these?
        #elif msg_type == 'sync_request':
        #elif msg_type == 'sync_response':

    def receive(msg=M, from_=sender):
        #logger.info('receive', M, sender)
        dst, msg = M
        if type(dst) == list:
            for d in dst:
                receive_handler((d, msg), sender)
        else:
            receive_handler(M, sender)

    def receive_handler(M, sender):
        dst, msg = M
        if dst == 'executor':
            # this is a committed message which just needs to be stored in the message history
            # for liveness checking at the end
            return
        rnd = get_round(msg)
        src = process_to_id[sender][0]
        if src not in twins:
            first_to_enter[rnd] = min(first_to_enter.get(rnd, datetime.max), datetime.now())
        if rnd == nrounds:
            # allow replica to respond to syncup messages?
            # no because padded partitions after GST mean all replicas should enter the 
            # last round without needing syncup (i think)
            return
        receivers = id_to_process[dst]
        for receiver in receivers:
            if can_send(sender, receiver, rnd):
                super().send((msg, src), receiver)
        

def main():
    config(channel = 'reliable')
    test_cases = []
    # TODO parse list of TestConfig from file generated by test generator
    #if len(sys.argv) > 1:
    #    test_case_names = sys.argv[1:]
    #else:
    #    test_case_names = map(lambda s: s[:-3], filter(lambda s: '.da' in s, os.listdir('configs')))
    #for test_case_name in test_case_names:
    #    test_module = importlib.import_module("configs." + test_case_name)
    #    test_cases.append((
    #        test_case_name,
    #        test_module.config,
    #        test_module.failure_config
    #    ))

    if not(os.path.isdir("log")):
        os.mkdir("log")

    # manually create a test case
    #rounds = [Round('a', [["a", "b", "d"], ["c", "d'"]], [])]
    rounds = [Round('a', [["a", "b", "c", "d", "d'"]], [])]
    gst = [Round('a', [["a", "b", "c", "d", "d'"]], []) for _ in range(7)]
    test_cases.append(TestConfig(['a','b','c','d'], ["d'"], rounds + gst, 0.8, 0, 'test', 30, 1))

    for test_config in test_cases:
        r = new(TestExec, (test_config,))
        start(r)
