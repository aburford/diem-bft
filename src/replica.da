# global variables in imported modules remain separate
# in different DistAlgo processes
import ledger
import pacemaker

class Replica(process):
	def setup(peers:set, clients:set):
		pass

	def run():
		output('started running')
		process_new_round_event(None)
		while not received(('done',)):
			round_done = False
			duration = pacemaker.get_round_timer(pacemaker.current_round)
			# loop: wait for next event M ; Main.start_event_processing(M)
			if await(round_done):
				pass
			# if M is a local timeout then Pacemaker.local timeout round()
			elif timeout(duration):
				pacemaker.local_timeout_round()
		output('finished running')
	
	# Procedure start event processing(M)
	def receive(msg=M, from_=sender):
		msg_type = M[0]
		# if M is a proposal message then process_proposal_msg(M)
		if msg_type == 'proposal':
			process_proposal_msg(M[1], sender)
		# if M is a vote message then process_vote_msg(M)
		elif msg_type == 'vote':
			process_vote_msg(M[1], sender)
		# if M is a timeout message then process_timeout_msg(M)
		elif msg_type == 'timeout':
			process_timeout_msg(M[1], sender)
		elif msg_type == 'request' and sender in clients:
			# process request from client
			txn = M[1]
			# check if duplicate (otherwise add to mempool.pending)
			duplicate = mempool.check_transaction(txn)
			if duplicate and leaderelection.get_leader(pacemaker.current_round) == self:
				# duplicate request, reply to client as the leader
				# (can two replicas think they're in different rounds and both reply?)
				send(('committed', txn), to=sender)
	
	# Procedure process certificate qc(qc)
	def process_certificate_qc(qc):
		# Block-Tree.process_qc(qc)
		# LeaderElection.update_leaders(qc)
		# Pacemaker.advance_round(qc.vote_info.round)	
		blocktree.process_qc(qc)
		leaderelection.update_leaders(qc)
		pacemaker.advance_round(qc.vote_info.round)

	def process_proposal_msg(P, sender):
		vote_msg = ('vote', tuple())
		current_round = pacemaker.current_round
		send(vote_msg, to=leaderelection.get_leader(current_round + 1))

	def process_timeout_msg(M):
		pass

	def process_vote_msg(M):
		process_new_round_event(None)

	def process_new_round_event(last_tc):
		if self == leaderelction.get_leader(pacemaker.current_round):
			b = blocktree.generate_block(mempool.get_transactions(), pacemake.current_round)
			# TODO make proposalmsg
			broadcast(('proposal', tuple()))

	def broadcast(msg):
		# TODO is it always safe to send to self?
		send(msg, to=peers)
