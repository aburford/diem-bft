# global variables in imported modules remain separate
# in different DistAlgo processes
import ledger
import blocktree
import pacemaker
from collections import deque
import mempool
import leaderelection
import safety

# TimeoutInfo
# │ round;
# │ high_qc;
# │ sender ← u; // Added automatically when constructed
# └ signature ← signu (round, high qc.round); // Signed automatically when constructed
class TimeoutInfo:
	def __init__(self, round, high_qc):
		self.round = round
		self.high_qc = high_qc

# TC
# │ round; // All timeout messages that form TC have the same round
# │ tmo_high_qc_rounds; // A vector of 2f + 1 high qc round numbers of timeout messages that form TC
# └ tmo_signatures; // A vector of 2f + 1 validator signatures on (round, respective high qc round)
class TC:
	def __init__(self, round, tmo_high_qc_rounds, tmo_signatures):
		self.round = round
		self.tmo_high_qc_rounds = tmo_high_qc_rounds
		self.tmo_signatures = tmo_signatures

# TimeoutMsg
# │ tmo_info; // TimeoutInfo for some round with a high qc
# │ last_round_tc; // TC for tmo_info.round − 1 if tmo_info.high_qc.round ̸= tmo_info.round − 1, else ⊥
# └ high_commit_qc; // QC to synchronize on committed blocks
class TimeoutMsg:
	def __init__(self, tmo_info, last_round_tc, high_commit_qc):
		self.tmo_info = tmo_info
		self.last_round_tc = last_round_tc
		self.high_commit_qc = high_commit_qc

# ProposalMsg
# │ block;
# │ last_round_tc; // TC for block.round − 1 if block.qc.vote_info.round ̸= block.round − 1, else ⊥
# │ high_commit_qc; // QC to synchronize on committed blocks
# └ signature ← signu(block.id);
class ProposalMsg:
	def __init__(self, block, last_round_tc, high_commit_qc):
		self.block = block
		self.last_round_tc = last_round_tc
		self.high_commit_qc = high_commit_qc

class Replica(process):
	def setup(peers:set, clients:set, transmission_delay_bound):
		recent_proposals = deque()
		leaderelection.validators = sorted(list(peers))
		pacemaker.transmission_delay_bound = transmission_delay_bound
		blocktree.u = str(self)

	# loop: wait for next event M ; Main.start_event_processing(M)
	# if M is a local timeout then Pacemaker.local_timeout_round()
	def run():
		output('started running')
		process_new_round_event(None)
		while not received(('done',)):
			round_done = False
			duration = pacemaker.get_round_timer(pacemaker.current_round)
			if await(round_done):
				pass
			elif timeout(duration):
				pacemaker.local_timeout_round()
		output('finished running')
	
	# Procedure start event processing(M)
	# │ if M is a proposal message then process_proposal_msg(M)
	# │ if M is a vote message then process_vote_msg(M)
	# └ if M is a timeout message then process_timeout_msg(M)
	def receive(msg=M, from_=sender):
		msg_type = M[0]
		output('received message %s from: %s' % (M, sender))
		if msg_type == 'proposal':
			process_proposal_msg(M[1], sender)
		elif msg_type == 'vote':
			process_vote_msg(M[1], sender)
		elif msg_type == 'timeout':
			process_timeout_msg(M[1], sender)
		elif msg_type == 'request' and sender in clients:
			# process request from client
			txn = M[1]
			# check if duplicate (otherwise add to mempool.pending)
			commit_state_id = mempool.check_transaction(txn, sender)
			if commit_state_id:
				# duplicate request, reply to client
				output('sending reply to client %s: %s' % (('committed', txn, commit_state_id), sender))
				send(('committed', txn, commit_state_id), to=sender)
	
	# Procedure process_certificate_qc(qc)
	# │ Block-Tree.process_qc(qc)
	# │ LeaderElection.update_leaders(qc)
	# └ Pacemaker.advance_round(qc.vote_info.round)	
	def process_certificate_qc(qc):
		committed_payload, commit_state_id = blocktree.process_qc(qc)
		if committed_payload != None:
			mempool.commit_transactions(committed_payload, commit_state_id, clients)
		leaderelection.update_leaders(qc)
		pacemaker.advance_round(qc.vote_info.round)
	
	# Procedure process_proposal_msg(P)
	# │ process_certificate_qc(P.block.qc)
	# │ process_certificate_qc(P.high_commit_qc)
	# │ Pacemaker.advance_round_tc(P.last_round_tc)
	# │ round ← Pacemaker.current_round
	# │ leader ← LeaderElection.get_leader(current_round)
	# │ if P.block.round ≠ round V P.sender ≠ leader V P.block.author ≠ leader then
	# │ └ return
	# │ Block-Tree.execute_and_insert(P) // Adds a new speculative state to the Ledger
	# │ vote_msg ← Safety.make_vote(P.block, P.last_round_tc)
	# │ if vote_msg ≠ ⊥ then
	# └ └ send vote_msg to LeaderElection.get_leader(current_round + 1)
	def process_proposal_msg(P, sender):
		process_certificate_qc(P.block.qc)
		process_certificate_qc(P.high_commit_qc)
		pacemaker.advance_round_tc(P.last_round_tc)
		current_round = pacemaker.current_round
		leader = leaderelection.get_leader(current_round)
		if P.block.round != current_round or sender != leader or P.block.author != leader:
			return
		blocktree.execute_and_insert(P.block)
		vote_msg = ('vote', safety.make_vote(P.block, P.last_round_tc))
		if vote_msg:
			send(vote_msg, to=leaderelection.get_leader(current_round + 1))

	def process_timeout_msg(M, sender):
		process_certificate_qc(M.tmo_info.high_qc)
		process_certificate_qc(M.high_commit_qc)
		pacemaker.advance_round_tc(M.last_round_tc)
		tc = pacemaker.process_remote_timeout(M)
		if tc:
			pacemaker.advance_round(tc)
			process_new_round_event(tc)

	def process_vote_msg(M, sender):
		qc = blocktree.process_vote(M)
		if qc:
			process_certificate_qc(qc)
			process_new_round_event(None)

	def process_new_round_event(last_tc):
		if self == leaderelection.get_leader(pacemaker.current_round):
			output('%s is now leader for current round %d' % (self, pacemaker.current_round))
			# TODO in rust implementation, blockstore has path_from_commit_root method
			# which returns list of uncommitted but proposed transactions from the last committed
			# block to the currently proposed block (i think?)
			# this is needed to tell mempool what txns are already proposed and in consensus
			# so we don't propose a duplicate txn
			# so something like this:
			exclude_payloads = [block.payload for block in blocktree.path_from_commit_root()]
			b = blocktree.generate_block(mempool.get_transactions(exclude_payloads), pacemaker.current_round)
			broadcast(('proposal', ProposalMsg(b, last_tc, blocktree.high_commit_qc)))

	def broadcast(msg):
		send(msg, to=peers)
