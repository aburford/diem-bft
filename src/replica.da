# global variables in imported modules remain separate
# in different DistAlgo processes
import ledger
import blocktree
import pacemaker
from collections import deque
import mempool
import leaderelection

# TimeoutInfo
# │ round;
# │ high_qc;
# │ sender ← u; // Added automatically when constructed
# └ signature ← signu (round, high qc.round); // Signed automatically when constructed
class TimeoutInfo:
	def __init__(self, round, high_qc):
		self.round = round
		self.high_qc = high_qc

# TC
# │ round; // All timeout messages that form TC have the same round
# │ tmo_high_qc_rounds; // A vector of 2f + 1 high qc round numbers of timeout messages that form TC
# └ tmo_signatures; // A vector of 2f + 1 validator signatures on (round, respective high qc round)
class TC:
	def __init__(self, round, tmo_high_qc_rounds, tmo_signatures):
		self.round = round
		self.tmo_high_qc_rounds = tmo_high_qc_rounds
		self.tmo_signatures = tmo_signatures

# TimeoutMsg
# │ tmo_info; // TimeoutInfo for some round with a high qc
# │ last_round_tc; // TC for tmo_info.round − 1 if tmo_info.high_qc.round ̸= tmo_info.round − 1, else ⊥
# └ high_commit_qc; // QC to synchronize on committed blocks
class TimeoutMsg:
	def __init__(self, tmo_info, last_round_tc, high_commit_qc):
		self.tmo_info = tmo_info
		self.last_round_tc = last_round_tc
		self.high_commit_qc = high_commit_qc

# ProposalMsg
# │ block;
# │ last_round_tc; // TC for block.round − 1 if block.qc.vote_info.round ̸= block.round − 1, else ⊥
# │ high_commit_qc; // QC to synchronize on committed blocks
# └ signature ← signu(block.id);
class ProposalMsg:
	def __init__(self, block, last_round_tc, high_commit_qc, signature):
		self.block = block
		self.last_round_tc = last_round_tc
		self.high_commit_qc = high_commit_qc
		self.signature = signature

class Replica(process):
	def setup(peers:set, clients:set):
		recent_proposals = deque()
		leaderelection.validators = sorted(list(peers))

	def run():
		output('started running')
		process_new_round_event(None)
		while not received(('done',)):
			round_done = False
			duration = pacemaker.get_round_timer(pacemaker.current_round)
			# loop: wait for next event M ; Main.start_event_processing(M)
			if await(round_done):
				pass
			# if M is a local timeout then Pacemaker.local timeout round()
			elif timeout(duration):
				pacemaker.local_timeout_round()
		output('finished running')
	
	# Procedure start event processing(M)
	# │ if M is a proposal message then process_proposal_msg(M)
	# │ if M is a vote message then process_vote_msg(M)
	# └ if M is a timeout message then process_timeout_msg(M)
	def receive(msg=M, from_=sender):
		msg_type = M[0]
		output('received message %s from: %s' % (M, sender))
		if msg_type == 'proposal':
			process_proposal_msg(M[1], sender)
		elif msg_type == 'vote':
			process_vote_msg(M[1], sender)
		elif msg_type == 'timeout':
			process_timeout_msg(M[1], sender)
		elif msg_type == 'request' and sender in clients:
			# process request from client
			txn = M[1]
			# check if duplicate (otherwise add to mempool.pending)
			duplicate = mempool.check_transaction(txn)
			if duplicate and leaderelection.get_leader(pacemaker.current_round) == self:
				# duplicate request, reply to client as the leader
				# (can two replicas think they're in different rounds and both reply?)
				output('sending reply to client %s: %s' % (('committed', txn), sender))
				send(('committed', txn), to=sender)
	
	# Procedure process_certificate_qc(qc)
	# │ Block-Tree.process_qc(qc)
	# │ LeaderElection.update_leaders(qc)
	# └ Pacemaker.advance_round(qc.vote_info.round)	
	def process_certificate_qc(qc):
		committed = blocktree.process_qc(qc)
		mempool.commit_transactions()
		# TODO tell clients that we committed their requests
		#if str(self) == qc.vote_info.parent_id:
		#	for txn in committed:
		#		send(txn, to=)
		leaderelection.update_leaders(qc)
		pacemaker.advance_round(qc.vote_info.round)
	
	def process_proposal_msg(P, sender):
		#process_certificate_qc(P)
		vote_msg = ('vote', tuple())
		current_round = pacemaker.current_round
		send(vote_msg, to=leaderelection.get_leader(current_round + 1))

	def process_timeout_msg(M, sender):
		pass

	def process_vote_msg(M, sender):
		process_new_round_event(None)

	def process_new_round_event(last_tc):
		if self == leaderelection.get_leader(pacemaker.current_round):
			output('%s is now leader for current round %d' % (self, pacemaker.current_round))
			b = blocktree.generate_block(mempool.get_transactions(), pacemaker.current_round)
			# TODO make proposalmsg
			broadcast(('proposal', tuple()))

	def broadcast(msg):
		# TODO is it always safe to send to self?
		send(msg, to=peers)
