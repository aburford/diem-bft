# global variables in imported modules remain separate
# in different DistAlgo processes
import ledger
import blocktree
import pacemaker
from collections import deque
import mempool
import leaderelection

class Replica(process):
	def setup(peers:set, clients:set):
		recent_proposals = deque()
		leaderelection.validators = sorted(list(peers))

	def run():
		output('started running')
		process_new_round_event(None)
		while not received(('done',)):
			round_done = False
			duration = pacemaker.get_round_timer(pacemaker.current_round)
			# loop: wait for next event M ; Main.start_event_processing(M)
			if await(round_done):
				pass
			# if M is a local timeout then Pacemaker.local timeout round()
			elif timeout(duration):
				pacemaker.local_timeout_round()
		output('finished running')
	
	# Procedure start event processing(M)
	# │ if M is a proposal message then process_proposal_msg(M)
	# │ if M is a vote message then process_vote_msg(M)
	# └ if M is a timeout message then process_timeout_msg(M)
	def receive(msg=M, from_=sender):
		msg_type = M[0]
		output('received message %s from: %s' % (M, sender))
		if msg_type == 'proposal':
			process_proposal_msg(M[1], sender)
		elif msg_type == 'vote':
			process_vote_msg(M[1], sender)
		elif msg_type == 'timeout':
			process_timeout_msg(M[1], sender)
		elif msg_type == 'request' and sender in clients:
			# process request from client
			txn = M[1]
			# check if duplicate (otherwise add to mempool.pending)
			duplicate = mempool.check_transaction(txn)
			if duplicate and leaderelection.get_leader(pacemaker.current_round) == self:
				# duplicate request, reply to client as the leader
				# (can two replicas think they're in different rounds and both reply?)
				output('sending reply to client %s: %s' % (('committed', txn), sender))
				send(('committed', txn), to=sender)
	
	# Procedure process certificate qc(qc)
	# │ Block-Tree.process_qc(qc)
	# │ LeaderElection.update_leaders(qc)
	# └ Pacemaker.advance_round(qc.vote_info.round)	
	def process_certificate_qc(qc):
		committed = blocktree.process_qc(qc)
		mempool.commit_transactions()
		# TODO tell clients that we committed their requests
		#if str(self) == qc.vote_info.parent_id:
		#	for txn in committed:
		#		send(txn, to=)
		leaderelection.update_leaders(qc)
		pacemaker.advance_round(qc.vote_info.round)
	
	def process_proposal_msg(P, sender):
		#process_certificate_qc(P)
		vote_msg = ('vote', tuple())
		current_round = pacemaker.current_round
		send(vote_msg, to=leaderelection.get_leader(current_round + 1))

	def process_timeout_msg(M, sender):
		pass

	def process_vote_msg(M, sender):
		process_new_round_event(None)

	def process_new_round_event(last_tc):
		if self == leaderelection.get_leader(pacemaker.current_round):
			output('%s is now leader for current round %d' % (self, pacemaker.current_round))
			b = blocktree.generate_block(mempool.get_transactions(), pacemaker.current_round)
			# TODO make proposalmsg
			broadcast(('proposal', tuple()))

	def broadcast(msg):
		# TODO is it always safe to send to self?
		send(msg, to=peers)
