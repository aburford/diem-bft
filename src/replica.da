# global variables in imported modules remain separate
# in different DistAlgo processes
import ledger
import blocktree
import pacemaker
from collections import deque
import mempool
import leaderelection
import safety
import random

class Replica(process):
    def setup(
        replica_ids,
        client_ids,
        transmission_delay_bound,
        public_keys,
        private_key,
        id,
        seed,
        server_ids,
        num_faulty
    ):
        safety.public_keys = public_keys
        safety.private_key = private_key
        safety.u = to_str()

        recent_proposals = deque()
        leaderelection.validators = sorted(list(replica_ids))
        pacemaker.transmission_delay_bound = transmission_delay_bound
        pacemaker.f = num_faulty
        pacemaker.exclude_size = num_faulty
        blocktree.u = to_str()
        blocktree.f = num_faulty
        pacemaker.f = num_faulty

        random.seed(seed)
    
    # __str__ doesn't seem to work with DistAlgo...
    def to_str():
        return 'replica' + str(id)

    # loop: wait for next event M ; Main.start_event_processing(M)
    # if M is a local timeout then Pacemaker.local_timeout_round()
    def run():
        output('started running')
        process_new_round_event(None)
        pacemaker.start_timer(0)
        while not received(('done',)):
            round_done = False
            (duration, paused) = pacemaker.get_round_timer(pacemaker.current_round)
            if await(round_done):
                pass
            elif timeout(duration):
                if not(paused):
                    pacemaker.local_timeout_round(broadcast)
        output('finished running')
    
    # Procedure start event processing(M)
    # │ if M is a proposal message then process_proposal_msg(M)
    # │ if M is a vote message then process_vote_msg(M)
    # └ if M is a timeout message then process_timeout_msg(M)
    def receive(msg=M, from_=sender):
        sender = self.server_ids.get(sender)
        msg_type = M[0]
        output('received message %s from: %s' % (M, sender))
        if msg_type == 'proposal':
            process_proposal_msg(M[1], sender)
        elif msg_type == 'vote':
            process_vote_msg(M[1], sender)
        elif msg_type == 'timeout':
            process_timeout_msg(M[1], sender)
        elif msg_type == 'request' and sender in client_ids:
            # process request from client
            txn = M[1]
            # check if duplicate (otherwise add to mempool.pending)
            commit_state_id = mempool.check_transaction(txn, sender)
            if commit_state_id:
                # duplicate request, reply to client
                output('sending reply to client %s: %s' % (('committed', txn, commit_state_id), sender))
                send(('committed', txn, commit_state_id), to=sender)
    
    # Procedure process_certificate_qc(qc)
    # │ Block-Tree.process_qc(qc)
    # │ LeaderElection.update_leaders(qc)
    # └ Pacemaker.advance_round(qc.vote_info.round) 
    def process_certificate_qc(qc):
        if qc != None:
            committed_payload, commit_state_id = blocktree.process_qc(qc)
            if committed_payload != None:
                mempool.commit_transactions(committed_payload, commit_state_id, clients)
            leaderelection.update_leaders(qc)
            pacemaker.advance_round_qc(qc.vote_info.round)
    
    # Procedure process_proposal_msg(P)
    # │ process_certificate_qc(P.block.qc)
    # │ process_certificate_qc(P.high_commit_qc)
    # │ Pacemaker.advance_round_tc(P.last_round_tc)
    # │ round ← Pacemaker.current_round
    # │ leader ← LeaderElection.get_leader(current_round)
    # │ if P.block.round ≠ round V P.sender ≠ leader V P.block.author ≠ leader then
    # │ └ return
    # │ Block-Tree.execute_and_insert(P) // Adds a new speculative state to the Ledger
    # │ vote_msg ← Safety.make_vote(P.block, P.last_round_tc)
    # │ if vote_msg ≠ ⊥ then
    # └ └ send vote_msg to LeaderElection.get_leader(current_round + 1)
    def process_proposal_msg(P, sender):
        process_certificate_qc(P.block.qc)
        process_certificate_qc(P.high_commit_qc)
        pacemaker.advance_round_tc(P.last_round_tc)
        current_round = pacemaker.current_round
        leader = leaderelection.get_leader(current_round)
        if P.block.round != current_round or \
            sender != leader or \
            P.block.author != leader:
            return
        blocktree.execute_and_insert(P.block)
        vote_msg = safety.make_vote(P.block, P.last_round_tc)
        if vote_msg:
            send(('vote', vote_msg), to=leaderelection.get_leader(current_round + 1))

    def process_timeout_msg(M, sender):
        process_certificate_qc(M.tmo_info.high_qc)
        process_certificate_qc(M.high_commit_qc)
        pacemaker.advance_round_tc(M.last_round_tc)
        tc = pacemaker.process_remote_timeout(broadcast, M)
        if tc:
            pacemaker.advance_round_tc(tc)
            process_new_round_event(tc)

    def process_vote_msg(M, sender):
        qc = blocktree.process_vote(M)
        if qc:
            process_certificate_qc(qc)
            process_new_round_event(None)

    def process_new_round_event(last_tc):
        if to_str() == leaderelection.get_leader(pacemaker.current_round):
            output('%s is now leader for current round %d' % (self, pacemaker.current_round))
            # TODO in rust implementation, blockstore has path_from_commit_root method
            # which returns list of uncommitted but proposed transactions from the last committed
            # block to the currently proposed block (i think?)
            # this is needed to tell mempool what txns are already proposed and in consensus
            # so we don't propose a duplicate txn
            # so something like this:
            exclude_payloads = [block.payload for block in blocktree.path_from_commit_root()]
            b = blocktree.generate_block(
                mempool.get_transactions(exclude_payloads),
                pacemaker.current_round
            )
            broadcast(('proposal', blocktree.ProposalMsg(b, last_tc, blocktree.high_commit_qc)))

    def broadcast(msg):
        send(msg, to=replica_ids)
