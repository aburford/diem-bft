import nacl.hash
import ledger

HASHER = nacl.hash.sha256

# pending_block_tree; // tree of blocks pending commitment
# pending_votes; // collected votes per block indexed by their LedgerInfo hash
pending_votes = {}
# highest known QC
high_qc = None
# highest QC that serves as a commit certificate
high_commit_qc = None

class PendingBlock:
    def __init__(block):
        self.block = block
        self.children = []

class PendingBlockTree:
    def __init__():
        self.id_to_block = {}

    def add(block):
        pending_block = PendingBlock(block)
        self.id_to_block[block.id] = pending_block
        if block.parent_id in self.id_to_block:
            self.id_to_block[parent_id].children.add(pending_block)

    def dfs(new_tree, pending_block):
        new_tree[block.id] = pending_block
        for child in pending_block.children:
            dfs(new_tree, child)

    def prune(id):
        if id in id_to_block:
            new_tree = {}
            self.dfs(new_tree, id_to_block[id])
            self.id_to_block = new_tree

# VoteInfo
# │ id, round; // Id and round of block
# │ parent_id, parent round; // Id and round of parent
# └ exec_state id; // Speculated execution state
class VoteInfo:
    def __init__(self, vote_id, vote_round, parent_id, parent_round, exec_state_id):
        self.id = vote_id
        self.round = vote_round
        self.parent_id = parent_id
        self.parent_round = parent_round
        self.exec_state_id = exec_state_id

# // speculated new committed state to vote directly on
# LedgerCommitInfo
# │ commit_state_id; // ⊥ if no commit happens when this vote is aggregated to QC
# └ vote_info_hash; // Hash of VoteMsg.vote info
class LedgerCommitInfo:
    def __init__(self, commit_state_id, vote_info_hash):
        self.commit_state_id = commit_state_id
        self.vote_info_hash = vote_info_hash

# VoteMsg
# │ vote_info; // A VoteInfo record
# │ ledger_commit_info; // Speculated ledger info
# │ high_commit_qc; // QC to synchronize on committed blocks
# │ sender ← u; // Added automatically when constructed
# └ signature ← signu(ledger commit info); // Signed automatically when constructed
class VoteMsg:
    def __init__(self, vote_info, ledger_commit_info, high_commit_qc):
        self.vote_info = vote_info
        self.ledger_commit_info = ledger_commit_info
        self.high_commit_qc = high_commit_qc

# // QC is a VoteMsg with multiple signatures
# QC
# │ vote_info;
# │ ledger_commit_info;
# │ signatures; // A quorum of signatures
# │ author ← u; // The validator that produced the qc
# └ author_signature ←signu(signatures);
class QC:
    def __init__(self, vote_info, ledger_commit_info, signatures):
        self.vote_info = vote_info
        self.ledger_commit_info = ledger_commit_info
        self.signatures = signatures

# Block
# │ author; // The author of the block, may not be the same as qc.author after view-change
# │ round; // The round that generated this proposal
# │ payload ; // Proposed transaction(s)
# │ qc ; // QC for parent block
# └ id; // A unique digest of author, round, payload, qc.vote_info.id and qc.signatures
class Block:
    def __init__(self, author, block_round, payload, qc):
        self.author = author
        self.round = block_round
        self.payload = payload
        self.qc = qc
        # TODO: add author, qc.vote_info.id, and qc.signatures
        self.id = HASHER(self.round.to_bytes(8, "big") + self.payload.encode("utf-8"))

# QC with the highest round
def max_qc(qc1, qc2):
    if qc1.round > qc2.round:
        return qc1
    else:
        return qc2

# Procedure process_qc(qc)
# │ if qc.ledger_commit_info.commit_state id != ⊥ then
# │ │ Ledger.commit(qc.vote_info.parent_id) 
# │ │ pending_block_tree.prune(qc.vote_info.parent_id) // parent id becomes
# │ │   the new root of pending
# │ └ high_commit_qc ← max{round}(qc, high_commit_qc)
# └ high qc ← max{round}(qc, high_qc)
# TODO we can't just return the round of the committed block, we must reparse the transactions from the payload
# because  if the next leader didn't see a requested transaction, they still need to store it in committed cache
# in case of a  duplicate request
# JK actually i'm not sure... maybe instead of assuming the leader will reply to duplicate requests, we only have the
# node that proposed the block  with that transaction reply.
# maybe clarify with professor how he expects this to  work, will he care if all nodes reply?
def process_qc(qc):
    if qc.ledger_commit_info.commit_state_id != None:
        ledger.commit(qc.vote_info.parent_id)
        pending_block_tree.prune(qc.vote_info.parent_id)
        high_commit_qc = max_qc(qc, high_commit_qc)
    	high_qc = max_qc(qc, high_qc)
		block = ledger.committed_block(qc.vote_info.parent_id)
		return block.round, qc.ledger_commit_info.commit_state_id
    high_qc = max_qc(qc, high_qc)
	return (None, None)

# Procedure execute_and_insert(b)
# │ Ledger.speculate(b.qc.block_id, b.id, b.payload)
# └ pending_block_tree.add(b)
def execute_and_insert(b):
    if b.qc == None:
        # We are the genesis block
        ledger.speculate("", b.id, b.payload)
    else:
        ledger.speculate(b.qc.block_id, b.id, b.payload)
    pending_block_tree.add(b)

# Function process_vote(v)
# │ process_qc(v.high_commit_qc)
# │ vote_idx ← hash(v.ledger_commit_info)
# │ pending_votes[vote_idx] ← pending_votes[vote_idx] U ∪v.signature
# │ if |pending_votes[vote_idx]|= 2f + 1 then
# │ │ qc ← QC <
# │ │ │ vote_info ← v.vote_info,
# │ │ │ state_id ← v.state_id,
# │ │ └ votes ← pending_votes[vote_idx] >
# │ └ return qc
# └ return ⊥
def process_vote(v):
    process_qc(v.high_commit_qc)
    vote_idx = HASHER(v.ledger_commit_info)
    if not(vote_idx in pending_votes):
        pending_votes[vote_idx] = set()
    pending_votes[vote_idx].add(v.signature)
    if len(pending_votes[vote_idx]) == 2 * f + 1:
        return QC(
            v.vote_info,
            v.state_id,
            pending_votes[vote_idx]
        )
    else:
        return None

# Function generate_block(txns,current_round)
# │ return Block <
# │ │ author ← u,
# │ │ round ← current_round,
# │ │ payload ← txns,
# │ │ qc ← high_qc,
# └ └ id ← hash(author || round || payload || qc.vote_info.id || qc.signatures) >
def generate_block(txns, current_round):
    return Block(
        # TODO: replace "me" with something that uniquely identifies the
        # process
        "me",
        current_round,
        txns,
        high_qc,
    )
