import safety 
import blocktree 
import replica

current_round = 0 # Initially zero
last_round_tc = None # Initially ⊥
pending_timeouts = [] # Timeouts per round

def get_round_timer(r):
    #return 4 * num_faulty
    return 4 * transmission_delay_bound  # Δ is in configuration, to be rename...
    #return 4 * r

#def start_timer(new_round):
    # not recommend to use await()
    #stop_timer(current_round)
    #current_round = new_round
    
        #start_local_timer
    #clk = logical_clock()
    #await(): pass
    #elif timeout(get_round_timer(current_round)):

    #if timeout():
    #    local_timeout_round()
    #for duration in get_round_timer(current_round):
        #for round current round: 
            #start_local_timer                     
# TODO restart timeout timer in case timeout gets lost
def local_timeout_round(broadcast):
    #save_consensus_state()
    timeout_info = safety.make_timeout(current_round, blocktree.high_qc, last_round_tc)

    timeout_msg = replica.TimeoutMsg(timeout_info, last_round_tc, blocktree.high_commit_qc)
    broadcast(('timeout', timeout_msg))

def process_remote_timeout(tmo):
    tmo_info = tmo.tmo_info
    if tmo_info.round < current_round: 
        return None
    if tmo_info.sender not in pending_timeouts[tmo_info.round].senders:
        pending_timeouts[tmo_info.round] = pending_timeouts[tmo_info.round].union(tmo_info)
    if len(pending_timeouts[tmo_info.round].senders) == f + 1: 
        stop_timer(current_round)
        local_timeout_round()  #Bracha timeout
    if len(pending_timeouts[tmo_info.round].senders) == 2*f + 1: 
        round = tmo_info.round
        # tmo high qc rounds ← {t.high qc.round | t ∈ pending timeouts[tmo info.round]}
        tmo_high_qc_rounds = setof(t.high_qc.round, t in pending_timeouts[tmo_info.round])
        # signatures ← {t.signature | t ∈ pending timeouts[tmo info.round]}i)
        signatures = setof(t.signature, t in pending_timeouts[tmo_info.round])
        timeout_certificate = TC(round,tmo_high_qc_rounds,signatures)
        return timeout_certificate
    return None

def advance_round_tc(tc):
    if tc == None or  tc.round < current_round: 
        return False
    last_round_tc = tc
    start_timer(tc.round + 1)
    return True

def advance_round_qc(qc_round):
    if qc_round < current_round:
        return False
    last_round_tc = None
    start_timer(qc_round + 1)
    return True
