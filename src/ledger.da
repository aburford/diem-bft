import nacl.hash
import os
import logging
from collections import OrderedDict

logging = None
HASHER = nacl.hash.sha256
id_to_pending = {}
# We only need to store the max(window_size, 2 * |validators|) most recently 
# committed blocks
committed_blocks = OrderedDict()
pending_block_to_state = {}

window_size = 5

ledger_file = None

def open_ledger(filename):
    global ledger_file

    if not(os.path.isdir("ledger")):
        os.mkdir("ledger")
    # TODO: get LEDGER_ID filename from configuration
    ledger_file = open("ledger/" + filename, "w+")

def close_ledger():
    close(ledger_file)

class LedgerState:
    def __init__(self, prev_block_id, block_id, txns):
        self.prev_block_id = prev_block_id
        self.block_id = block_id
        self.txns = txns
        self.commands = "".join([txn[0] + "\n" for txn in txns])

        self.children = []
        if prev_block_id in pending_block_to_state:
            parent = pending_block_to_state[prev_block_id]
            parent.children.append(self)
            self.parent_state_id = parent.id
        else:
            # We are the genesis block. Set self.parent_state_id so
            # that HASHER doesn't yell at us
            self.parent_state_id = b'' 

        self.id = HASHER(
            self.parent_state_id + self.commands.encode('utf-8')
        )

# speculate(prev_block_id, block_id, txns) // apply txns speculatively
def speculate(prev_block_id, block_id, txns):
    state = LedgerState(
        prev_block_id,
        block_id,
        txns
    )
    pending_block_to_state[block_id] = state
    
# pending state(block_id) // find the pending state for the given block id or âŠ¥
# if not present
def pending_state(block_id):
    state = pending_block_to_state.get(block_id)
    if state:
        return state.id
    else:
        return None

def commit_prefix(state):
    global pending_block_to_state

    # Commit the state only if it is pending
    if state.block_id in pending_block_to_state:
        # If the parent is not committed, commit it first
        if state.parent_state_id in pending_block_to_state:
            commit_prefix(pending_block_to_state[state.parent_state_id])
        ledger_file.write(state.commands)
        ledger_file.flush()
        os.fsync(ledger_file.fileno())
        # TODO: add the committed block to committed_blocks
        pending_block = pending_block_tree.id_to_block.get(state.block_id)
        committed_blocks[state.block_id] = pending_block.block
        # here is where we would pop the front of committed_queue when it has more than
        #if len(committed_blocks) > max(window_size, 2 * validators):
        #    committed_blocks.pop(list(committed_blocks.keys())[0])
        # but instead we do not bound committed_blocks' size so that replicas may fall arbitrarily far behind but still catch up easily
        # they could still catch up if we read from the ledger and a replica waited for f + 1 matching ledger replies to catch up but that loses linearity

def dfs(new_pending, state):
    for child in state.children:
        new_pending[child.block_id] = child
        dfs(new_pending, child)

# commit(block_id) // commit the pending prefix of the given block id and prune
# other branches
def commit(block_id):
    global pending_block_to_state

    if block_id in pending_block_to_state:
        state = pending_block_to_state[block_id]
        # Commit the pending prefix
        commit_prefix(state)
        logging.info(f"Commit the pending prefix of block id = [{block_id}]")
        # Prune the other branches  
        new_pending = {}
        dfs(new_pending, state)
        pending_block_to_state = new_pending

# committed_block(block_id) // returns a committed block given its id
def committed_block(block_id):
    return committed_blocks.get(block_id)

# return path from block_id to most recent committed block
def get_commit_chain(block_id):
    if not committed_block(block_id):
        return []
    block_ids = list(committed_blocks.keys())
    i = block_ids.index(block_id)
    chain = []
    while i < len(committed_blocks):
        chain.append(committed_blocks[block_ids[i]])
        i += 1
    return chain
    
