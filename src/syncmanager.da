import blocktree
import ledger
from blocktree import SyncRequestMsg, SyncResponseMsg
import pacemaker

syncing = False
syncing_high_commit_qc = None
syncing_high_qc = None
# TODO are these ProcessID objects or to_str() ids?
attempted_peers = set()
msg_queue = []
# set by Replica
u = None
multicast = None
process_certificate_qc = None
handle_msg = None
server_ids = None

# TODO how is round incremented if we catch up on rounds with timeouts in between?

# return True if we need to sync up before processing this proposal
def need_sync(remote_high_commit_qc, remote_high_qc, msg, src):
    global syncing
    global syncing_high_commit_qc
    global syncing_high_qc
    if syncing:
        msg_queue.append((msg, src))
        print('%s is already syncing' % u)
        return True
    syncing_high_commit_qc = remote_high_commit_qc
    syncing_high_qc = remote_high_qc
    if not synced():
        print('%s starting new sync up to ' % u, syncing_high_qc.vote_info.id)
        syncing = True
        msg_queue.append((msg, src))
        send_sync_request()
        return True
    return False

# shouldn't actually be necessary to implement because we can timeout and sync up with the next leader's proposal
def need_vote_sync(remote_high_commit_qc, vote_info, msg, src):
    if not blocktree.pending_block_tree.contains(vote_info.id):
        return True

def process_sync_request(sync_request, src):
    #print('sync_request')
    #print('high_commit:', sync_request.high_commit_qc.vote_info.parent_id)
    #print('high_qc', sync_request.high_qc, sync_request.high_qc.vote_info.id)
    #print(blocktree.pending_block_tree.id_to_block[sync_request.high_qc.vote_info.id].block.qc)
    if blocktree.pending_block_tree.contains(sync_request.high_qc.vote_info.id):
        process_certificate_qc(sync_request.high_qc)
    block_id = sync_request.high_commit_qc.vote_info.parent_id if sync_request.high_commit_qc else None
    chain = ledger.get_commit_chain(block_id)
    path = blocktree.path_from_commit_root()
    #print('pending block tree:', blocktree.pending_block_tree.id_to_block)
    #print('chain:', [b.id for b in chain])
    #print('path:', [b.id for b in path])
    resp = SyncResponseMsg(chain, path)
    multicast(('sync_response', resp), src)

def process_sync_response(sync_response, src):
    print('%s got sync response' % u)
    if not syncing:
        return False
    # first catch up high_commit_qc
    if not sync_high_commit_qc(sync_response):
        print('failed to sync high_commit_qc')
    if not sync_high_qc(sync_response):
        print('failed to sync high_qc')

    # check if we're done
    if synced():
        print('%s finished syncing up with %s' % (u, server_ids[src]))
        end_sync()
    else:
        print('%s failed to sync with response from %s' % (u, server_ids[src]))
        attempted_peers.add(server_ids[src])
        send_sync_request()


# ---------------
# private methods
# ---------------


def high_commit_qc_synced():
    if syncing_high_commit_qc == None:
        return True
    if blocktree.high_commit_qc and syncing_high_commit_qc.vote_info.parent_round < blocktree.high_commit_qc.vote_info.parent_round:
        return True
    return blocktree.pending_block_tree.contains(syncing_high_commit_qc.vote_info.parent_id)

def high_qc_synced():
    # first proposal
    if syncing_high_qc == None:
        return True
    if blocktree.high_qc and syncing_high_qc.vote_info.round < blocktree.high_qc.vote_info.round:
        return True
    return blocktree.pending_block_tree.contains(syncing_high_qc.vote_info.id)

def synced():
    return high_commit_qc_synced() and high_qc_synced()

def send_sync_request():
    # first bring high_commit_qc up to date
    req = SyncRequestMsg(blocktree.high_commit_qc, syncing_high_qc)
    qc = syncing_high_qc if high_commit_qc_synced() else syncing_high_commit_qc
    signators = {replica for replica, signature in qc.signatures}
    # randomly pop a replica from the quorum
    # if we timeout, let the next proposal trigger a new sync
    not_tried = signators - attempted_peers
    # there must be non faulty nodes in signators
    # so if we received a response, it would end the sync
    # and clear attempted_peers
    assert len(not_tried)
    multicast(('sync_request', req), not_tried.pop())

def timeout():
    global syncing
    if syncing:
        print('%s sync ending due to timeout' % u)
    msg_queue.clear()
    attempted_peers.clear()
    end_sync()

def end_sync():
    global syncing
    syncing = False
    msg_queue.reverse()
    while(len(msg_queue)):
        handle_msg(*msg_queue.pop())
    attempted_peers.clear()

def sync_high_commit_qc(sync_response):
    if not len(sync_response.commit_chain):
        return False
    if syncing_high_commit_qc and sync_response.commit_chain[-1].round < syncing_high_commit_qc.vote_info.parent_round:
        return False
    # root of commit_chain should have qc referencing our own highest committed block
    for block in sync_response.commit_chain:
        if block.qc and not blocktree.pending_block_tree.contains(block.qc.vote_info.id):
            print('------not sure why this happens--------')
            return False
        process_certificate_qc(block.qc)
        blocktree.execute_and_insert(block)
    return True

def sync_high_qc(sync_response):
    if not len(sync_response.high_qc_path):
        return False
    if sync_response.high_qc_path[-1].round < syncing_high_qc.vote_info.round:
        return False
    for block in sync_response.high_qc_path:
        if not blocktree.pending_block_tree.contains(block.qc.vote_info.id):
            # we could receive a path whose prefix we have already committed
            # so continue until we have the pending parent block
            continue
        process_certificate_qc(block.qc)
        blocktree.execute_and_insert(block)
    return True
        

